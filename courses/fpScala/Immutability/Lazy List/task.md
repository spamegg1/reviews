## Lazy List

A lazy list in Scala is a collection that evaluates its elements lazily: each element is computed only once, 
the first time it is needed, and then stored for subsequent access. 
Lazy lists can be infinite: their elements are computed on-demand. Hence, if your program keeps accessing the next element 
in a loop, the lazy list will inevitably grow until the program fails with an out-of-memory error. 
In practice, however, you will likely need only a finite number of elements.
While this number might be large and unknown from the start, since the lazy list will compute only  
explicitly requested values, it allows developers to work with large datasets or sequences in a memory-efficient manner. 
In such cases, a lazy list provides a convenient method to implement the logic for computing the consecutive elements 
until you decide to stop. 
You can use it in certain specific cases where otherwise, you would need to code an elaborate data structure with mutable fields
and a method that would compute new values for those fields.


Below is an example of how to generate a Fibonacci sequence using a lazy list in Scala:

```
lazy val fib: LazyList[BigInt] =
  BigInt(0) #::
    BigInt(1) #::
    fib.zip(fib.tail).map { case (a, b) => a + b }

// Fetch and print the first 10 Fibonacci numbers
fib.take(10).foreach(println)
```

In the above code:
* `#::` is an operator that creates a new lazy list with a specified head (the element in front of the operator)
  and a tail (the lazy list after the operator). 
  We start with `BigInt(0)` as the head, and the expression after `#::` becomes the tail. 
  Now, this tail comprises a head (`BigInt(1)`) and another tail linked with the `#::` operator. 
  This second "internal" tail is constructed with the `zip` method operating on the original lazy list, `fib`. 
  It’s possible to access `fib` from this point in the code because the list is lazy — the expression will not be evaluated 
  immediately upon the lazy list's construction, but only later when `fib` already exists and we want to access one of its elements.
* `fib.zip(fib.tail)` takes two sequences, `fib` and its tail (i.e., `fib` without its first element), and zips them together into pairs. 
  The Fibonacci sequence is generated by summing each pair `(a, b) => a + b` of successive Fibonacci numbers.
* `take(10)` is used to fetch the first 10 Fibonacci numbers from the lazy list, and `foreach(println)` prints them. 
  Note that the Fibonacci sequence is theoretically infinite, but it doesn't cause any issues or out-of-memory errors 
  (at least not yet), thanks to lazy evaluation.
* Alternatively, you can use `takeWhile` to compute consecutive elements of the lazy list until a certain requirement is fulfilled.
* The methods opposite to `take` and `takeWhile` — `drop` and `dropWhile` — can be used to compute and then ignore 
  a certain number of elements in the lazy list or compute and ignore elements until a certain requirement is met. 
  These methods can be chained. 
  For example, `fib.drop(5).take(5)` will compute the first 10 elements of the Fibonacci sequence but will ignore the first 5 of them.

To learn more about the methods of Scala's `LazyList`, read its [documentation](https://www.scala-lang.org/api/current/scala/collection/immutable/LazyList.html).

### Exercise 

Implement the function that generates an infinite lazy list of prime numbers in ascending order. 
Use the Sieve of Eratosthenes algorithm.
